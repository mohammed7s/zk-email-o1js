# Zk Email o1js

ZK Email is an o1js library that allows for verification of email DKIM signatures and selective text from
the body of a sent or received email. The library also acts as a toolkit for the app developer who wishes to incorporate email verification functionality in their o1js/Mina applications.

This project is an o1js implementation of [zk-email](https://github.com/zkemail/zk-email-verify). o1js uses the Mina proving system [Kimchi](https://o1-labs.github.io/proof-systems/specs/kimchi.html#kimchi) for its circuits and offers an alternative implementation to circom and halo2 based implementations. 

Moreover, since the whole blckchain execution environment is a zk circuit, o1js allows for writing write smart contracts and other circuit logic in one language. 


## Quickstart 

#### To Install

```
git clone 
npm install 
```

#### To quickly check validity of an eml file 

1. Place raw email (.eml) file in /eml folder 
2. Modify the VARIABLE of the file in eml-check.ts

```
const filePath = path.join(__dirname, '../../eml/email.eml');
```

3. Build and run

```sh
npm run build && node build/src/main.js 

```
This will process the .eml file, and generate inputs for the circuit, then calls the `verify_email` function to validate the inputs in o1js environment.  

#### To use as toolkit for developing an o1js application with email verification functionality

 follow these steps: 

1. Generate the Regex circuit 
2. Write the smart contract logic
3. Generate circuit inputs from raw eml file (frontend)

A more thorough guide on developing an application is in this file along with a tutorial. 


#### To run tests & coverage

```sh
npm run test
npm run testw # watch mode

```
```sh
npm run coverage

```

#### To run benchmarks 

## Background and Motivation 

Smart contract platforms like Mina, Ethereum, and Polkadot offer an independent execution environment for agreements, simulating the concept of a "world computer." This paradigm allows for unprecedented possibilities, but it also introduces the oracle problem: how to get external data into smart contracts. For example, proving a bank transfer to release an NFT or verifying employment before providing feedback on a decentralized social media platform. Integrating real-world data into smart contracts enriches their functionality.

One approach to bringing data on-chain is using a network of oracles, which relies on a majority-reward-minority-slash model to ensure honesty. Another approach is having data sources sign the data, with a registry of public keys on-chain for verification. This method maintains data privacy and eliminates the need for a network of staked oracles. While some data, like weather services or financial data, may not be signed and thus better suited for oracles, many modern systems like passports, ID cards, and emails already use digital signatures, making them ideal for the second approach.

ZK Email o1js leverages this second paradigm by allowing users to prove to a smart contract that they received an email with specific information, triggering on-chain actions. This can be used to prove ownership of a social media handle, control of a company email, or receipt of an autogenerated statement from a service like Binance. By using zero-knowledge (ZK) circuits, users can prove computations without revealing sensitive information, addressing privacy concerns and reducing gas fees associated with large emails.

The initial implementation of zk-email was in circom and verified on Ethereum, achieving privacy and scalability goals. The o1js implementation offers the advantage of writing smart contracts and circuit logic in one application, thanks to Mina's zk circuit execution environment. Users generate proofs client-side and send them for verification on the Mina network, ensuring privacy and scalability by only logging the proof of execution on the public blockchain.

## Library guide 

/`email-verify.ts`   
Contains the core functionality of the library. It verifies a DKIM signature using the provided message, signature, and public key. It also optionally checks the body hash if it matches the one in the header. 

List of inputs: 

	paddedHeader: Bytes,
	headerHashIndex: Field,
	signature: Bigint2048,
	publicKey: Bigint2048,
	modulusLength: number,
	bodyHashCheck: boolean,
	paddedBodyRemainingBytes: Bytes,
	precomputedHash: Bytes,
	bodyHashIndex: Field,
	headerBodyHashIndex: Field


The input can take bodyHashCheck = true or false 

At its core, it verifies the signature using RSA siganture. The RSAVerify from the o1js-rsa library takes three inputs the signature, publicKey, message. Where the message needs to be constructed inside the function from paddedHeader and headerhashIndex. The message is the hashed header then pkcs15 encoded. 


/`generate-inputs.ts`  
Contains the preprocessing of the raw email file (.eml) 
Purpose: used in an application's frontend to handle the eml file. 

/`zkapp.ts`  
e2e example of a twitter handle verification in smart contract. Use this as a template or reference for an application implementation. 

/`main.ts`  
change name to `eml-test.ts`
Purpose: This file can be used as a test for an eml file. 
It will generate inputs and call email verify. 

/`utils.ts`  
Purpose: has a bunch of supporting utils for functionality of the library. 
- pkcs1v15Pad
- bodyHashRegex
- selectSubarray


## Dependencies 

#### zk-email helpers  
We utilize the offchain [helpers](https://github.com/zkemail/zk-email-verify/tree/5613d743773927fa4fbee1472b6aed6bde34a6cc/packages/helpers) from the zkemail library, particularly the DKIM parser class to generate the inputs that would go in the circuit. This is implemented in the `generate-inputs.ts` file. The choice to use the original zk email library helpers to generate inputs is that we can benefit from code audits and better compatibility with other zk-email apps in the future.

#### RSA-o1js
The key functionality of the DKIM signature is the RSA signature verification. The library simply handles the dkim formatting rules and ensures that we can handle all types of emails. 
https://github.com/Shigoto-dev19/o1js-rsa
https://www.npmjs.com/package/o1js-rsa

#### Base64-o1js  

https://github.com/Shigoto-dev19/o1js-base64


#### Dynamic and updateable SHA: provide comments


## Troubleshooting 

1. `Error: DKIM signature verification failed for domain androidloves.me. Reason: DNS failure: ESERVFAIL`
   This is an internet issue. try a different internet connection or disable vpn if enabled.

note: this section is small for now. Please submit issues no matter how silly so we can maintain a public list of problems and solutions for future developers. 



## [How ZK Email Works](/docs/how_zkemail_works.md)

Check this docs page for details on how the library works. 


## Benchmarks 

## Contribution 

How to contribute:
-submit issues 
-submit PRs 

Regex standards for different emails. We would like to keep email library of Regex's (twitter handle check, ..etc). Maybe we can add a folder for community regex's. send as PR. 


## Acknowledgment
zk-email team who led the way and ventured and provided a well documented library, and documentation, and who were quick and responsive to answer our questions on the telegram group. 

Mina foundation for funding the zkignite series 

zkignite participants who have helped in discussions like Rahul, Lauri, 

o1js labs (gregor, florian, and others) for mentorship and guidance 


## Known problems 

- Hotmail and protonmail not working in the helpers. 


## Further development // directions 

- Compute and add domain check regex function
- RFC compliance of the email verify standard for DKIM. 
- develop a universal DKIM registry for the Mina ecosystem with incentivized oracle network of DNS servers.
- Handling very large emails: kimchi is ideal for recursion and would be cool to experiment with very large emails.  
- experiment with wallets 


## Feedback

telegram  
form   
submit an issue 


## Support 

The project is a public good project. 

Mina multisig address: 

The funds will be used for the maintenance and development of the following milestones


## License

[Apache-2.0](LICENSE)








