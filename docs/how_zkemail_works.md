## How ZKemail works 

#### Why zk email?


We would like to prove to a smart contract that a person received an email with some information on it which would trigger some action onchain.  

There are many examples of why one would want to do this (prove ownership of social media handle, prove you control some company email address thereby proving employment at that company, prove an autogenerated statement by Binance, ..etc) See other examples here. Having such proofs in our smart contracts enriches what we can do with smart contracts to interact with real world.

Almost most applications would have a user (a prover) claiming they have some email with some speific information. The role of the smart contract is to host the verification logic and ask the user to submit their full eml file to be processed by the smart contract. If it verifies, then the smart contract logic can base an action (eg.release of funds, or minting an ownership NFT) based on it. 

However smart contracts in public blockchains raise a privacy concern for the user, the email might contain information a user may not wish to disclose (for example, full name, or full addresses,..etc.) to the world. The use of ZK circuits comes in here. They allow us to prove a computation has occurred and produced a specific public output (eg. the twitter handle the user wishes to claim onchain). This reduces the problem to just verifying the proof generated by the user and verifying the public output in smart contract. Also, this happens to solve another scalaibility issue of gas fees increasing with size of emails (we might want to verify trading history from a Binance email which is 100MBs large). By generating a much smaller size proof on the client side no matter how large the original email size is, this allows for much more applications to be feasible.  

The first implemetation of zk-email was written in circom and verified in Ethereum smart contracts achieves exactly the privacy/scalibility goals mentioned. The o1js advantage (also an advantage for all zk DSLs like cairo, noir..etc) is that implementation allows for smart contracts and circuit logic to be written in one application. This is because Mina's execution environment is intself a zk circuit. So the user generates the proof of execution client side and sends for verifiction on the Mina network without revealing all the data. What gets logged on the public blockchain is just a proof of the execution from the user. Thereby also achieving the privacy and scalibility requirement.  


### Understanding your email 

Email server: 
Email client 
DNS Registry 


### What we want from Emails?

There are two main functions we need to perform: 

1. **Check email authenticity**: We do this by checking the DKIM signature that comes with an email. We want to be 100% sure the email has not been tampered with and we want to be sure that the public key that signed it is in fact the domain public key registered in DNS registry. 

2. **Check specific content**: If we are sure that the email body is authentic, then we can use it as input to a regex circuit that can look for specific character sequences in it in verifiable code (i.e onchain). 

These two checks are sufficient to unlock some features in a smart contract, with the trust assumption that the email server that sent the email is secure. 

### DKIM Signatures 

Most emails today are signed by the domain that sent it using a public key infrastructure (a public and private key pair) like RSA for example.  The domain to public key mapping is stored in the DNS records of the domain. The DNS records are like the internet phonebook and copies of this database are stored in many DNS servers. Email mailboxes use the email signature to verify the identity of email senders to detect phishing and scam attempts and that the original message has not been tampered with in transit.

These signatures are known as DKIM (DomainKeys Identified Mail) signatures. The standard for DKIM signatures is formalized in an internet standard [RFC 6337](https://datatracker.ietf.org/doc/html/rfc6376). This standard is maintained by the IETF (Internet Engineering Task Force, a non profit entity). The standard specifies which parts of the emails are signed and how data is formatted. 

An example of dkim signature found in the header of an email:

```
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=androidloves.me;
	s=2019022801; t=1584218937;
	h=from:from:reply-to:subject:subject:date:date:message-id:message-id:
	 to:to:cc:content-type:content-type:
	 content-transfer-encoding:content-transfer-encoding;
	bh=aeLbTnlUQQv2UFEWKHeiL5Q0NjOwj4ktNSInk8rN/P0=;
	b=eJPHovlwH6mU2kj8rEYF2us6TJwQg0/T7NbJ6A1zHNbVJ5UJjyMOfn+tN3R/oSsBcSDsHT
	xGysZJIRPeXEEcAOPNqUV4PcybFf/5cQDVpKZtY7kj/SdapzeFKCPT+uTYGQp1VMUtWfc1
	SddyAZSw8lHcvkTqWhJKrCU0EoVAsik=
```

v: version of the DKIM key record
a: The algorithm used for hashing (sha256) and signing (RSA)  
c: message canocicalization: how is message formatted before signing  
d: domain used for the DNS lookup  
s: Selector for the public key  
t: signature timestamp  
h: header fields used as message in signature  
bh: body hash of body in base64 encoded    
b: base64 encoded signature  

Presented with a signature above, we can verify a DKIM signature using these steps:

a. check the signature algorithm. In an RSA example, we will need the public key, the signature

1. Get the public Key for a domain from a DNS server: query any DNS server to obtain the public key of a domain using s and d. It returns a p value for public key that looks like this:

```
"v=DKIM1; k=rsa; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcaywJn59dbp7TbRiDsVloBdCsgl9wAEvHo9WCDSNRqDJjkF1Fjy44Q4emckHP/Tv7hJdIlBtV8hEw5zGD+/kKkhnlx04BSYqXuxed1nOq6FDjNTIR6TmHetMfVU1IcO7ewyJZp5/2uM64JmTDh2u3ed4+JR7jqFE2e/ZqBTM1iQIDAQAB"
```
2. Construct the exact header message that is signed. Exact header format is specified in the parameter h. 
3. Hash the header message from 2. 
4. Format using pkcs1.5 encoding [see here](https://datatracker.ietf.org/doc/html/rfc3447#section-9.2)
5. verify the [RSA](https://cryptobook.nakov.com/digital-signatures/rsa-signatures) signature using the signature b, public key p and the hashed header obtained from step 4. Note: We know its RSA signing algorithm because of a. 

Another check that is usually performed as an extra measure is the body hash check which is field bh in the header that should correspond to the body b To perform this check: 
6. Calculate the hash of the body from b 
7. compare the hash with the base64 decoded value bh from the DKIM-signature header of the email 

These steps are summarized in the following diagram:
![alt text](zkEmail-architecture.png)

### Regex Circuits 

- Background of zkregex and why its desirable 
- For more thorough explanation, explre the README of the regex repo: 
- Downside: if html format changes, then well have redeploy again 

Explain the reveal and out 

where we use it in the library? 
core: for headers, body checks 
app specific: 

it might be worth hosting regex libraries. Please submit PRs. 

explain how they integrate together 


### Trust assumptions of emails  

If these two checks pass for our given application, then we can be sure this email was sent from that email server. Of course, the trust assumption is the email server. We cannot be sure the email server of x.com has not been hijacked by an internal employee to forge an email. (This is like saying someone got access to the king's stamp in 18th century and forged a letter). Hence there is an underlying assumption that we trust these servers for our given application. How much trust and on which domain servers will be application specific.   







